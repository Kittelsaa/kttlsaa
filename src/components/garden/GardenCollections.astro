---
import { getCollection } from "astro:content";

// Get all topics and counts if not provided as props
const { topics = [], counts = {} } = Astro.props;

// If no topics provided, get them from the collection
let allTopics = topics;
let topicCounts = counts;

if (topics.length === 0) {
  const notes = await getCollection("notes");
  allTopics = [...new Set(notes.flatMap(note => note.data.topics || []))].sort();
  
  // Count notes per topic
  allTopics.forEach(topic => {
    topicCounts[topic] = notes.filter(note => 
      note.data.topics && note.data.topics.includes(topic)
    ).length;
  });
}

// Use the specific topics from the garden
const displayTopics = [
  { name: "AI", count: topicCounts["AI"] || 1 },
  { name: "Digital Anthropology", count: topicCounts["Digital Anthropology"] || 3 },
  { name: "Tech", count: topicCounts["Tech"] || 2 }
];
---

<div class="garden-collections">
  <div class="collections-container">
    <!-- First row: Main collections (2 columns) -->
    <div class="row main-row">
      <div class="cell">
        <h3 class="item-title">BOOKSHELF</h3>
        <p class="item-desc">A list of the books I'm reading, sometimes with additional notes.</p>
      </div>
      
      <div class="cell">
        <h3 class="item-title">MAP OF INQUIRY</h3>
        <p class="item-desc">A map of the subjects I find interesting and want to learn more about.</p>
      </div>
    </div>
    
    <!-- Second row: Topics (3 columns) -->
    <div class="row topics-row">
      {displayTopics.map((topic) => (
        <div class="cell topic-filter" data-topic={topic.name}>
          <div class="topic-link">
            <h3 class="item-title">{topic.name}</h3>
            <p class="item-desc">{topic.count} {topic.count === 1 ? 'Item' : 'Items'}</p>
          </div>
        </div>
      ))}
    </div>
  </div>
</div>

<style>
  .garden-collections {
    margin-bottom: 3rem;
    padding-top:0px;
  }
  
  .collections-container {
    border: 1px solid #e5e7eb;
    width: 100%;
    background-color: #ffffff;
  }
  
  .row {
    display: flex;
    width: 100%;
  }
  
  .main-row .cell {
    width: 50%;
  }
  
  .topics-row .cell {
    width: 33.333%;
  }
  
  .cell {
    padding: 1.5rem;
    border-right: 1px solid #e5e7eb;
    border-bottom: 1px solid #e5e7eb;
    transition: background-color 0.2s ease;
  }
  
  .main-row .cell:last-child,
  .topics-row .cell:last-child {
    border-right: none;
  }
  
  .topics-row .cell {
    border-bottom: none;
  }
  
  .topic-link {
    display: block;
    height: 100%;
  }
  
  .topic-filter {
    cursor: pointer;
  }
  
  .topic-filter:hover {
    background-color: #f9fafb;
  }
  
  .topic-filter.active {
    background-color: #f3f4f6;
    border-bottom: 2px solid var(--color-accent, #ff8c00);
  }
  
  .item-title {
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: #1f2937;
    font-family: var(--font-heading, 'Averia Serif Libre', serif);
  }
  
  .item-desc {
    font-size: 0.875rem;
    color: #6b7280;
    margin: 0;
  }
  
  @media (max-width: 767px) {
    .row {
      flex-direction: column;
    }
    
    .cell {
      width: 100% !important;
      border-right: none;
    }
    
    .topics-row .cell:not(:last-child) {
      border-bottom: 1px solid #e5e7eb;
    }
  }
</style>

<script>
  // Client-side filtering logic
  document.addEventListener('DOMContentLoaded', () => {
    const topicFilters = document.querySelectorAll('.topic-filter');
    const noteCards = document.querySelectorAll('.note-card');
    
    // Add "All" filter state
    let currentFilter = 'all';
    
    // Add click event to each topic filter
    topicFilters.forEach(filter => {
      filter.addEventListener('click', () => {
        const selectedTopic = filter.getAttribute('data-topic');
        
        // Toggle active state if clicking the same filter again
        if (currentFilter === selectedTopic) {
          currentFilter = 'all';
          topicFilters.forEach(f => f.classList.remove('active'));
        } else {
          // Remove active class from all filters
          topicFilters.forEach(f => f.classList.remove('active'));
          
          // Add active class to clicked filter
          filter.classList.add('active');
          currentFilter = selectedTopic;
        }
        
        // Filter notes
        filterNotes(currentFilter);
      });
    });
    
    // Function to filter notes by topic
    function filterNotes(topic) {
      noteCards.forEach(card => {
        // Get topics from the card's data attribute
        const cardTopics = card.getAttribute('data-topics')?.split(',') || [];
        
        if (topic === 'all' || cardTopics.includes(topic)) {
          card.style.display = 'block';
        } else {
          card.style.display = 'none';
        }
      });
    }
  });
</script>




